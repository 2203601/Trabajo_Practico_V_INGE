# azure-pipelines.yml
# Soluci√≥n de Sincronizaci√≥n de Datos QA -> PROD (Costo Cero con SQLite y Docker)

trigger:
  branches:
    include:
      - main

pool:
  name: SelfHosted

variables:
    # üõëüõ†Ô∏è 1. ACTUALIZAR: Nombre del Grupo de Recursos (Necesario para Azure CLI)
    RESOURCE_GROUP_NAME: 'TPS-INGE-2025' 
    # üõëüõ†Ô∏è 2. ACTUALIZAR: Nombre de tu conexi√≥n general de Azure (para App Services y CLI)
    azureServiceConnection: 'azure-tp05-connection'
    # üõëüõ†Ô∏è 3. ACTUALIZAR: Nombre de la conexi√≥n al ACR (Docker Registry)
    azureContainerRegistryConnection: 'azure-tp05-connection'
    
    # Nombres de App Services
    backendAppNameQA: 'Coffeehub-Back-QA'
    frontendAppNameQA: 'Coffeehub-Front-QA'
    backendAppNameProd: 'Coffeehub-Back-Prod'
    frontendAppNameProd: 'Coffeehub-Front-Prod'
    
    # Nombre del Repositorio/Imagen en ACR
    repositoryName: 'coffeehub-backend'


# ===============================
# BUILD STAGE (Construye la Imagen Docker de SQLite)
# ===============================
stages:
- stage: Build
  displayName: "Build Docker Image (SQLite)"
  jobs:
  - job: BuildJob
    steps:
      # 1. Construir y Publicar la Imagen del Backend (Contiene el c√≥digo SQLite)
      - task: Docker@2
        displayName: 'Build and Push Backend Image'
        inputs:
          # üõëüõ†Ô∏è 4. USAR LA VARIABLE DE CONEXI√ìN ACR CORREGIDA
          containerRegistry: '$(azureContainerRegistryConnection)' 
          repository: '$(repositoryName)'
          command: 'buildAndPush'
          Dockerfile: 'coffehub/backend/Dockerfile' 
          tags: |
            $(Build.BuildId)
          buildContext: '.'

      # 2. Publicar el Frontend est√°tico como artefacto
      - task: PublishPipelineArtifact@1
        inputs:
          targetPath: 'coffehub/frontend'
          artifact: 'frontend'
        displayName: "Publicar Frontend"


---

# ===============================
# DEPLOY QA (Contenedor √önico + Frontend)
# ===============================
- stage: Deploy_QA
  displayName: "Desplegar a QA"
  dependsOn: Build
  condition: succeeded()
  jobs:
  - deployment: DeployQA
    environment: 'QA'
    strategy:
      runOnce:
        deploy:
          steps:
            # 1. Despliega la Imagen Docker del Backend (SQLite)
            - task: AzureWebApp@1
              displayName: "Deploy Backend QA (Container)"
              inputs:
                # üõëüõ†Ô∏è 5. USAR LA VARIABLE DE CONEXI√ìN GENERAL
                azureSubscription: '$(azureServiceConnection)' 
                appName: '$(backendAppNameQA)'
                appType: 'webAppContainer'
                # üõëüõ†Ô∏è 6. ESPECIFICAR EL HOST DE ACR COMPLETO
                imageName: '$(azureContainerRegistryConnection)/$(repositoryName):$(Build.BuildId)'
            
            # 2. Despliega el Frontend est√°tico
            - task: DownloadPipelineArtifact@2
              inputs:
                artifact: 'frontend'
                path: '$(Pipeline.Workspace)/frontend'

            - task: AzureWebApp@1
              displayName: "Deploy Frontend QA"
              inputs:
                azureSubscription: '$(azureServiceConnection)'
                appName: '$(frontendAppNameQA)'
                package: '$(Pipeline.Workspace)/frontend'
                runtimeStack: 'NODE|18-lts'


---

# ---------------------------------
# SINCRONIZACI√ìN DE DATOS (Copia coffeehub.db)
# ---------------------------------
- stage: Sync_Data_QA_to_PROD
  displayName: "Sincronizar DB de QA a PROD (SQLite)"
  dependsOn: Deploy_QA
  condition: succeeded()
  jobs:
  - job: Sync
    displayName: "Copiar coffeehub.db"
    steps:
      - task: AzureCLI@2
        displayName: "Sincronizar DB v√≠a CLI"
        inputs:
          azureSubscription: '$(azureServiceConnection)'
          scriptType: 'bash'
          scriptLocation: 'inlineScript'
          inlineScript: |
            DB_FILE='coffeehub.db'
            SOURCE_APP=$(backendAppNameQA)
            TARGET_APP=$(backendAppNameProd)
            RG=$(RESOURCE_GROUP_NAME)
            
            # 1. Descargar el archivo coffeehub.db desde el App Service QA al Agente
            echo "1. Descargando DB de QA ($SOURCE_APP)..."
            az webapp log download --name $SOURCE_APP --resource-group $RG --log-file $DB_FILE --path '/home/site/wwwroot/$DB_FILE' || { 
              echo "Error: No se pudo descargar el archivo $DB_FILE. Aseg√∫rese de que el archivo existe en QA." 
              exit 1 
            }
            
            # 2. Subir el archivo coffeehub.db al App Service PROD (Sobrescribe la DB de PROD)
            echo "2. Subiendo DB a PROD ($TARGET_APP)..."
            zip -r db_transfer.zip $DB_FILE
            az webapp deploy --name $TARGET_APP --resource-group $RG --type zip --src-path db_transfer.zip --target-path '/home/site/wwwroot/'
            
            echo "‚úÖ Datos de QA ($DB_FILE) copiados a PROD. Sincronizaci√≥n completada."



# ===============================
# DEPLOY PROD (Contenedor √önico + Frontend)
# ===============================
- stage: Deploy_PROD
  displayName: "Desplegar a Producci√≥n"
  dependsOn: Sync_Data_QA_to_PROD 
  condition: succeeded()
  jobs:
  - deployment: DeployPROD
    environment: 'PROD'
    strategy:
      runOnce:
        deploy:
          steps:
            # 1. Despliega la Imagen Docker del Backend (que ahora usa la DB sincronizada)
            - task: AzureWebApp@1
              displayName: "Deploy Backend PROD (Container)"
              inputs:
                azureSubscription: '$(azureServiceConnection)'
                appName: '$(backendAppNameProd)'
                appType: 'webAppContainer'
                imageName: '$(azureContainerRegistryConnection)/$(repositoryName):$(Build.BuildId)' # üõëüõ†Ô∏è USAR EL HOST DE ACR COMPLETO

            # 2. Despliega el Frontend est√°tico
            - task: DownloadPipelineArtifact@2
              inputs:
                artifact: 'frontend'
                path: '$(Pipeline.Workspace)/frontend'

            - task: AzureWebApp@1
              displayName: "Deploy Frontend PROD"
              inputs:
                azureSubscription: '$(azureServiceConnection)'
                appName: '$(frontendAppNameProd)'
                package: '$(Pipeline.Workspace)/frontend'
                runtimeStack: 'NODE|18-lts'