# azure-pipelines.yml
# Soluci√≥n de Sincronizaci√≥n de Datos QA -> PROD (Costo Cero con SQLite y Docker)

trigger:
  branches:
    include:
      - main

pool:
  name: SelfHosted

variables:
    # üõë üõ†Ô∏è ACTUALIZAR ESTOS VALORES
    RESOURCE_GROUP_NAME: 'tu-nombre-del-resource-group' 
    azureServiceConnection: 'azure-tp05-connection'
    
    # Nombres de App Services (Backend: Contenedor, Frontend: Node)
    backendAppNameQA: 'Coffeehub-Back-QA'
    frontendAppNameQA: 'Coffeehub-Front-QA'
    backendAppNameProd: 'Coffeehub-Back-Prod'
    frontendAppNameProd: 'Coffeehub-Front-Prod'
    
    # Nombre del registro de contenedores
    azureContainerRegistry: 'tu_registro_docker_azure_service_connection' 
    repositoryName: 'coffeehub-backend'


# ===============================
# BUILD STAGE (Construye la Imagen Docker de SQLite)
# ===============================
stages:
- stage: Build
  displayName: "Build Docker Image (SQLite)"
  jobs:
  - job: BuildJob
    steps:
      # 1. Construir y Publicar la Imagen del Backend (Contiene el c√≥digo SQLite)
      - task: Docker@2
        displayName: 'Build and Push Backend Image'
        inputs:
          containerRegistry: '$(azureContainerRegistry)' 
          repository: '$(repositoryName)'
          command: 'buildAndPush'
          Dockerfile: 'coffehub/backend/Dockerfile' # Debe instalar sqlite3
          tags: |
            $(Build.BuildId)
          buildContext: '.'

      # 2. Publicar el Frontend est√°tico como artefacto
      - task: PublishPipelineArtifact@1
        inputs:
          targetPath: 'coffehub/frontend'
          artifact: 'frontend'
        displayName: "Publicar Frontend"


---

# ===============================
# DEPLOY QA (Contenedor √önico + Frontend)
# ===============================
- stage: Deploy_QA
  displayName: "Desplegar a QA"
  dependsOn: Build
  condition: succeeded()
  jobs:
  - deployment: DeployQA
    environment: 'QA'
    strategy:
      runOnce:
        deploy:
          steps:
            # 1. Despliega la Imagen Docker del Backend (SQLite)
            - task: AzureWebApp@1
              displayName: "Deploy Backend QA (Container)"
              inputs:
                azureSubscription: 'azure-tp05-connection'
                appName: '$(backendAppNameQA)'
                appType: 'webAppContainer'
                imageName: '$(azureContainerRegistry)/$(repositoryName):$(Build.BuildId)'
            
            # 2. Despliega el Frontend est√°tico
            - task: DownloadPipelineArtifact@2
              inputs:
                artifact: 'frontend'
                path: '$(Pipeline.Workspace)/frontend'

            - task: AzureWebApp@1
              displayName: "Deploy Frontend QA"
              inputs:
                azureSubscription: 'azure-tp05-connection'
                appName: '$(frontendAppNameQA)'
                package: '$(Pipeline.Workspace)/frontend'
                runtimeStack: 'NODE|18-lts'


---

# ---------------------------------
# SINCRONIZACI√ìN DE DATOS (Copia coffeehub.db)
# ---------------------------------
- stage: Sync_Data_QA_to_PROD
  displayName: "Sincronizar DB de QA a PROD (SQLite)"
  dependsOn: Deploy_QA
  condition: succeeded()
  jobs:
  - job: Sync
    displayName: "Copiar coffeehub.db"
    steps:
      - task: AzureCLI@2
        displayName: "Sincronizar DB v√≠a CLI"
        inputs:
          azureSubscription: '$(azureServiceConnection)'
          scriptType: 'bash'
          scriptLocation: 'inlineScript'
          inlineScript: |
            DB_FILE='coffeehub.db'
            SOURCE_APP=$(backendAppNameQA)
            TARGET_APP=$(backendAppNameProd)
            RG=$(RESOURCE_GROUP_NAME)
            
            # 1. Descargar el archivo coffeehub.db desde el App Service QA al Agente
            echo "1. Descargando DB de QA ($SOURCE_APP)..."
            az webapp log download --name $SOURCE_APP --resource-group $RG --log-file $DB_FILE --path '/home/site/wwwroot/$DB_FILE' || { 
              echo "Error: No se pudo descargar el archivo $DB_FILE. Aseg√∫rese de que el archivo existe en QA." 
              exit 1 
            }
            
            # 2. Subir el archivo coffeehub.db al App Service PROD (Sobrescribe la DB de PROD)
            echo "2. Subiendo DB a PROD ($TARGET_APP)..."
            # Comprimimos el archivo para el despliegue
            zip -r db_transfer.zip $DB_FILE
            # Usamos az webapp deploy para subir el archivo zip al directorio ra√≠z del contenedor
            az webapp deploy --name $TARGET_APP --resource-group $RG --type zip --src-path db_transfer.zip --target-path '/home/site/wwwroot/'
            
            echo "‚úÖ Datos de QA ($DB_FILE) copiados a PROD. Sincronizaci√≥n completada."


---

# ===============================
# DEPLOY PROD (Contenedor √önico + Frontend)
# ===============================
- stage: Deploy_PROD
  displayName: "Desplegar a Producci√≥n"
  dependsOn: Sync_Data_QA_to_PROD # Se ejecuta DESPU√âS de la sincronizaci√≥n de datos
  condition: succeeded()
  jobs:
  - deployment: DeployPROD
    environment: 'PROD'
    strategy:
      runOnce:
        deploy:
          steps:
            # 1. Despliega la Imagen Docker del Backend (que ahora usa la DB sincronizada)
            - task: AzureWebApp@1
              displayName: "Deploy Backend PROD (Container)"
              inputs:
                azureSubscription: 'azure-tp05-connection'
                appName: '$(backendAppNameProd)'
                appType: 'webAppContainer'
                imageName: '$(azureContainerRegistry)/$(repositoryName):$(Build.BuildId)'

            # 2. Despliega el Frontend est√°tico
            - task: DownloadPipelineArtifact@2
              inputs:
                artifact: 'frontend'
                path: '$(Pipeline.Workspace)/frontend'

            - task: AzureWebApp@1
              displayName: "Deploy Frontend PROD"
              inputs:
                azureSubscription: 'azure-tp05-connection'
                appName: '$(frontendAppNameProd)'
                package: '$(Pipeline.Workspace)/frontend'
                runtimeStack: 'NODE|18-lts'